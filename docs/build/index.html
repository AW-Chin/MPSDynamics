<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · MPS Docs</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MPS Docs</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>-</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.chaincoeffs_ohmic" href="#Main.MPSDynamics.chaincoeffs_ohmic"><code>Main.MPSDynamics.chaincoeffs_ohmic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">chaincoeffs_ohmic(nummodes, α, s, beta=&quot;inf&quot;; wc=1, soft=false)</code></pre><p>Generate chain coefficients for an Harmonic bath coupled to a spin-1/2 with spectral density given by: </p><p>soft cutoff: <span>$J(ω) = 2παω_c (\frac{ω}{ω_c})^s \exp(-ω/ω_c)$</span> </p><p>hard cutoff: <span>$J(ω) = 2παω_c (\frac{ω}{ω_c})^s θ(ω-ω_c)$</span></p><p>The Hamiltonian is given by:</p><p><span>$H = \frac{ω_0}{2}σ_z + Δσ_x + σ_x\sum_kg_k(b_k^\dagger+b_k) + \sum_kω_kb_k^\dagger b_k$</span></p><p>And the spectral density is defined by:</p><p><span>$J(ω) ≡ π\sum_k|g_k|^2δ(ω-ω_k)$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.measure1siteoperator-Tuple{Array{T,1} where T,Any,Array{Int64,1}}" href="#Main.MPSDynamics.measure1siteoperator-Tuple{Array{T,1} where T,Any,Array{Int64,1}}"><code>Main.MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(A, O)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site or just one if i is specified.</p><p>For calculating operators on single sites this will be more efficient if the site is on the left of the mps.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.measure2siteoperator-Tuple{Array{T,1} where T,Any,Any,Int64,Int64}" href="#Main.MPSDynamics.measure2siteoperator-Tuple{Array{T,1} where T,Any,Any,Int64,Int64}"><code>Main.MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> measure2siteoperator(A::Vector, M1, M2, j1, j2)</code></pre><p>Caculate expectation of M1*M2 where M1 acts on site j1 and M2 acts on site j2, assumes A is right normalised.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.physdims-Tuple{Array{T,1} where T}" href="#Main.MPSDynamics.physdims-Tuple{Array{T,1} where T}"><code>Main.MPSDynamics.physdims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">physdims(M)</code></pre><p>Return the physical dimensions of an MPS or MPO <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.productstatemps" href="#Main.MPSDynamics.productstatemps"><code>Main.MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(N::Int, d::Int, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an <code>N</code>-site MPS with all local Hilbert space dimensions given by <code>d</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.productstatemps" href="#Main.MPSDynamics.productstatemps"><code>Main.MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(physdims::Dims, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an MPS representing a product state with local Hilbert space dimensions given by <code>physdims</code>.</p><p>By default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, <code>Dmax</code> can be set accordingly.</p><p>The indvidual states of the MPS sites can be provdided by setting <code>state</code> to a list of column vectors. Setting <code>state=:Vacuum</code> will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting <code>state=:FullOccupy</code> will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).</p><p>The argument <code>mpsorthog</code> can be used to set the gauge of the resulting MPS.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.Radial" href="#Main.MPSDynamics.Radial"><code>Main.MPSDynamics.Radial</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tree iterators:</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.addchild!-Tuple{Main.MPSDynamics.Tree,Int64}" href="#Main.MPSDynamics.addchild!-Tuple{Main.MPSDynamics.Tree,Int64}"><code>Main.MPSDynamics.addchild!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addchild!(tree::Tree, id::Int)</code></pre><p>Add child to node <code>id</code> of <code>tree</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.addchildren!-Tuple{Main.MPSDynamics.Tree,Int64,Int64}" href="#Main.MPSDynamics.addchildren!-Tuple{Main.MPSDynamics.Tree,Int64,Int64}"><code>Main.MPSDynamics.addchildren!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addchildren!(tree::Tree, id::Int, n::Int)</code></pre><p>Add <code>n</code> children to node <code>id</code> of <code>tree</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.chainmps-Tuple{Int64,Array{Int64,1},Int64}" href="#Main.MPSDynamics.chainmps-Tuple{Int64,Array{Int64,1},Int64}"><code>Main.MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainmps(N::Int, sites::Vector{Int}, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal super-position over <code>sites</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.chainmps-Tuple{Int64,Int64,Int64}" href="#Main.MPSDynamics.chainmps-Tuple{Int64,Int64,Int64}"><code>Main.MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainmps(N::Int, site::Int, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations on <code>site</code></p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.chainprop-Tuple{Any,Any}" href="#Main.MPSDynamics.chainprop-Tuple{Any,Any}"><code>Main.MPSDynamics.chainprop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainprop(t, cparams...)</code></pre><p>Propagate an excitation placed initially on the first site of a tight-binding chain with parameters given by cparams for a time t and return occupation expectation for each site.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.dynamap-NTuple{4,Any}" href="#Main.MPSDynamics.dynamap-NTuple{4,Any}"><code>Main.MPSDynamics.dynamap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dynamap(ps1,ps2,ps3,ps4)</code></pre><p>Calulate complete dynamical map to time step at which ps1, ps2, ps3 and ps4 are specified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.elementmpo-Tuple{Any,Vararg{Any,N} where N}" href="#Main.MPSDynamics.elementmpo-Tuple{Any,Vararg{Any,N} where N}"><code>Main.MPSDynamics.elementmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementmpo(M, el...)</code></pre><p>Return the element of the MPO <code>M</code> for the set of physical states <code>el...</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.elementmps-Tuple{Any,Vararg{Any,N} where N}" href="#Main.MPSDynamics.elementmps-Tuple{Any,Vararg{Any,N} where N}"><code>Main.MPSDynamics.elementmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementmps(A, el...)</code></pre><p>Return the element of the MPS <code>A</code> for the set of physical states <code>el...</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = chainmps(6, [2,4], 1);

julia&gt; elementmps(A, 1, 2, 1, 1, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 1, 1, 2, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 2, 1, 2, 1, 1)
0.0

julia&gt; elementmps(A, 1, 1, 1, 1, 1, 1)
0.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.entanglemententropy-Tuple{Any}" href="#Main.MPSDynamics.entanglemententropy-Tuple{Any}"><code>Main.MPSDynamics.entanglemententropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">entanglemententropy(A)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the entanglement entropy for a bipartite cut for every bond.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.findchild-Tuple{Main.MPSDynamics.TreeNode,Int64}" href="#Main.MPSDynamics.findchild-Tuple{Main.MPSDynamics.TreeNode,Int64}"><code>Main.MPSDynamics.findchild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findchild(node::TreeNode, id::Int)</code></pre><p>Return integer corresponding to the which number child site <code>id</code> is of <code>node</code> </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.modemps" href="#Main.MPSDynamics.modemps"><code>Main.MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modemps(N::Int, k::Vector{Int}, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal superposition of modes <code>k</code> of a tight-binding chain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.modemps" href="#Main.MPSDynamics.modemps"><code>Main.MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modemps(N::Int, k::Int, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of mode <code>k</code> of a tight-binding chain. </p><p><code>chainparams</code> takes the form <code>[e::Vector, t::Vector]</code> where <code>e</code> are the on-site energies and <code>t</code> are the hoppping parameters.</p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.mpsembed!-Tuple{Array{T,1} where T,Int64}" href="#Main.MPSDynamics.mpsembed!-Tuple{Array{T,1} where T,Int64}"><code>Main.MPSDynamics.mpsembed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsembed(A::Vector, Dmax::Int)</code></pre><p>Embed MPS <code>A</code> in manifold of max bond-dimension <code>Dmax</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.mpsleftnorm!" href="#Main.MPSDynamics.mpsleftnorm!"><code>Main.MPSDynamics.mpsleftnorm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpsleftnorm!(A::Vector, jq::Int=length(A))</code></pre><p>Left orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.mpsmixednorm!-Tuple{Array{T,1} where T,Int64}" href="#Main.MPSDynamics.mpsmixednorm!-Tuple{Array{T,1} where T,Int64}"><code>Main.MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmixednorm!(A::Vector, OC::Int)</code></pre><p>Put MPS <code>A</code> into mixed canonical form with orthogonality centre on site <code>OC</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.mpsmixednorm!-Tuple{Main.MPSDynamics.TreeNetwork,Int64}" href="#Main.MPSDynamics.mpsmixednorm!-Tuple{Main.MPSDynamics.TreeNetwork,Int64}"><code>Main.MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmixednorm!(A::TreeNetwork, id::Int)</code></pre><p>Normalise tree-MPS <code>A</code> such that orthogonality centre is on site <code>id</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.mpsmoveoc!-Tuple{Main.MPSDynamics.TreeNetwork,Int64}" href="#Main.MPSDynamics.mpsmoveoc!-Tuple{Main.MPSDynamics.TreeNetwork,Int64}"><code>Main.MPSDynamics.mpsmoveoc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmoveoc!(A::TreeNetwork, id::Int)</code></pre><p>Move the orthogonality centre of right normalised tree-MPS <code>A</code> to site <code>id</code>.</p><p>This function will be more efficient than using <code>mpsmixednorm!</code> if the tree-MPS is already right-normalised.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.mpsrightnorm!" href="#Main.MPSDynamics.mpsrightnorm!"><code>Main.MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpsrightnorm!(A::Vector, jq::Int=1)</code></pre><p>Right orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.mpsrightnorm!-Tuple{Main.MPSDynamics.TreeNetwork}" href="#Main.MPSDynamics.mpsrightnorm!-Tuple{Main.MPSDynamics.TreeNetwork}"><code>Main.MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsrightnorm!(A::TreeNetwork)</code></pre><p>When applied to a tree-MPS, right normalise towards head-node.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.mpsshiftoc!-Tuple{Main.MPSDynamics.TreeNetwork,Int64}" href="#Main.MPSDynamics.mpsshiftoc!-Tuple{Main.MPSDynamics.TreeNetwork,Int64}"><code>Main.MPSDynamics.mpsshiftoc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsshiftoc!(A::TreeNetwork, newhd::Int)</code></pre><p>Shift the orthogonality centre by one site, setting new head-node <code>newhd</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.normmps-Tuple{Array{T,1} where T}" href="#Main.MPSDynamics.normmps-Tuple{Array{T,1} where T}"><code>Main.MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normmps(A::Vector; mpsorthog=:None)</code></pre><p>Calculate norm of MPS <code>A</code>.</p><p>Setting <code>mpsorthog</code>=<code>:Right</code>/<code>:Left</code> will calculate the norm assuming right/left canonical form. Setting <code>mpsorthog=OC::Int</code> will cause the norm to be calculated assuming the orthoganility center is on site <code>OC</code>. If mpsorthog is <code>:None</code> the norm will be calculated as an MPS-MPS product.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.normmps-Tuple{Main.MPSDynamics.TreeNetwork}" href="#Main.MPSDynamics.normmps-Tuple{Main.MPSDynamics.TreeNetwork}"><code>Main.MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normmps(net::TreeNetwork; mpsorthog=:None)</code></pre><p>When applied to a tree-MPS <code>mpsorthog=:Left</code> is not defined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.orthcentersmps-Tuple{Array{T,1} where T}" href="#Main.MPSDynamics.orthcentersmps-Tuple{Array{T,1} where T}"><code>Main.MPSDynamics.orthcentersmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orthcentersmps(A)</code></pre><p>Compute the orthoganality centres of MPS <code>A</code>.</p><p>Return value is a list in which each element is the corresponding site tensor of <code>A</code> with the orthoganility centre on that site. Assumes <code>A</code> is right normalised.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.randisometry-Tuple{Type,Int64,Int64}" href="#Main.MPSDynamics.randisometry-Tuple{Type,Int64,Int64}"><code>Main.MPSDynamics.randisometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randisometry([T=Float64], dims...)</code></pre><p>Construct a random isometry</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.randmps" href="#Main.MPSDynamics.randmps"><code>Main.MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randmps(tree::Tree, physdims, Dmax::Int, T::Type{&lt;:Number} = Float64)</code></pre><p>Construct a random, right-normalised, tree-MPS, with structure given by tree and max bond-dimension given by <code>Dmax</code>.</p><p>The local Hilbert space dimensions are specified by physdims which can either be of type <code>Dims{length(tree)}</code>, specifying the dimension of each site, or of type <code>Int</code>, in which case the same local dimension is used for every site.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.randmps" href="#Main.MPSDynamics.randmps"><code>Main.MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randmps(N::Int, d::Int, Dmax::Int, T=Float64)</code></pre><p>Construct a random, <code>N</code>-site, right-normalised MPS with all local Hilbert space dimensions given by <code>d</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Int64}, Tuple{Tuple{Vararg{Int64,N}},Int64,Type{#s5721} where #s5721&lt;:Number}} where N" href="#Main.MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Int64}, Tuple{Tuple{Vararg{Int64,N}},Int64,Type{#s5721} where #s5721&lt;:Number}} where N"><code>Main.MPSDynamics.randmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randmps(physdims::Dims{N}, Dmax::Int, T::Type{&lt;:Number} = Float64) where {N}</code></pre><p>Construct a random, right-normalised MPS with local Hilbert space dimensions given by <code>physdims</code> and max bond-dimension given by <code>Dmax</code>. </p><p><code>T</code> specifies the element type, eg. use <code>T=ComplexF64</code> for a complex valued MPS.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.randtree-Tuple{Int64,Int64}" href="#Main.MPSDynamics.randtree-Tuple{Int64,Int64}"><code>Main.MPSDynamics.randtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randtree(numnodes::Int, maxdegree::Int)</code></pre><p>Construct a random tree with <code>nummodes</code> modes and max degree <code>maxdegree</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.rmsd-Tuple{Any,Any}" href="#Main.MPSDynamics.rmsd-Tuple{Any,Any}"><code>Main.MPSDynamics.rmsd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmsd(dat1::Vector{Float64}, dat2::Vector{Float64})</code></pre><p>Calculate the root mean squared difference between two measurements of an observable over the same time period.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.svdmps-Tuple{Any}" href="#Main.MPSDynamics.svdmps-Tuple{Any}"><code>Main.MPSDynamics.svdmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svdmps(A)</code></pre><p>For a right normalised mps <code>A</code> compute the full svd spectrum for a bipartition at every bond.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MPSDynamics.svdtrunc-Tuple{Any}" href="#Main.MPSDynamics.svdtrunc-Tuple{Any}"><code>Main.MPSDynamics.svdtrunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">U, S, Vd = svdtrunc(A; truncdim = max(size(A)...), truncerr = 0.)</code></pre><p>Perform a truncated SVD, with maximum number of singular values to keep equal to <code>truncdim</code> or truncating any singular values smaller than <code>truncerr</code>. If both options are provided, the smallest number of singular values will be kept. Unlike the SVD in Julia, this returns matrix U, a diagonal matrix (not a vector) S, and Vt such that A ≈ U * S * Vt</p></div></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 June 2020 12:12">Monday 22 June 2020</span>. Using Julia version 1.0.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
