<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MPSDynamics.jl Documentation · MPSDynamics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MPSDynamics.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MPSDynamics.jl Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MPSDynamics.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MPSDynamics.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/angusdunnett/MPSDynamics/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MPSDynamics.jl-Documentation"><a class="docs-heading-anchor" href="#MPSDynamics.jl-Documentation">MPSDynamics.jl Documentation</a><a id="MPSDynamics.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#MPSDynamics.jl-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.MPOtoVector-Tuple{ITensors.MPO}" href="#MPSDynamics.MPOtoVector-Tuple{ITensors.MPO}"><code>MPSDynamics.MPOtoVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MPOtoVector(mpo::MPO)</code></pre><p>Convert an ITensors chain MPO into a form compatible with MPSDynamics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/fundamentals.jl#L372-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.addchild!-Tuple{MPSDynamics.Tree,Int64}" href="#MPSDynamics.addchild!-Tuple{MPSDynamics.Tree,Int64}"><code>MPSDynamics.addchild!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addchild!(tree::Tree, id::Int)</code></pre><p>Add child to node <code>id</code> of <code>tree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeBasics.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree,Int64,Int64}" href="#MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree,Int64,Int64}"><code>MPSDynamics.addchildren!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addchildren!(tree::Tree, id::Int, n::Int)</code></pre><p>Add <code>n</code> children to node <code>id</code> of <code>tree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeBasics.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chaincoeffs_ohmic-Tuple{Any,Any,Any}" href="#MPSDynamics.chaincoeffs_ohmic-Tuple{Any,Any,Any}"><code>MPSDynamics.chaincoeffs_ohmic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chaincoeffs_ohmic(N, α, s; ωc=1, soft=false)</code></pre><p>Generate chain coefficients <span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span> for an Harmonic bath at zero temperature with a power law spectral density given by:</p><p>soft cutoff: <span>$J(ω) = 2παω_c (\frac{ω}{ω_c})^s \exp(-ω/ω_c)$</span> </p><p>hard cutoff: <span>$J(ω) = 2παω_c (\frac{ω}{ω_c})^s θ(ω-ω_c)$</span></p><p>The coefficients parameterise the chain Hamiltonian</p><p><span>$H = H_S + c_0 A_S⊗B_0+\sum_{i=0}^{N-1}t_i (b_{i+1}^\dagger + b_i +h.c.) + \sum_{i=0}^{N-1} ϵ_ib_i^\dagger b_i$</span></p><p>which is unitarily equivalent (before the truncation to <code>N</code> sites) to</p><p><span>$H = H_S + A_S⊗\int_0^∞dω\sqrt{\frac{J(ω)}{π}}B_ω + \int_0^∞dωωb_ω^\dagger b_ω$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/models.jl#L353-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainmps-Tuple{Int64,Array{Int64,1},Int64}" href="#MPSDynamics.chainmps-Tuple{Int64,Array{Int64,1},Int64}"><code>MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainmps(N::Int, sites::Vector{Int}, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal super-position over <code>sites</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L237-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainmps-Tuple{Int64,Int64,Int64}" href="#MPSDynamics.chainmps-Tuple{Int64,Int64,Int64}"><code>MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainmps(N::Int, site::Int, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations on <code>site</code></p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainprop-Tuple{Any,Any}" href="#MPSDynamics.chainprop-Tuple{Any,Any}"><code>MPSDynamics.chainprop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainprop(t, cparams...)</code></pre><p>Propagate an excitation placed initially on the first site of a tight-binding chain with parameters given by cparams for a time t and return occupation expectation for each site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/fundamentals.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.dynamap-NTuple{4,Any}" href="#MPSDynamics.dynamap-NTuple{4,Any}"><code>MPSDynamics.dynamap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dynamap(ps1,ps2,ps3,ps4)</code></pre><p>Calulate complete dynamical map to time step at which ps1, ps2, ps3 and ps4 are specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/fundamentals.jl#L272-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.electron2kmps" href="#MPSDynamics.electron2kmps"><code>MPSDynamics.electron2kmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">electronkmps(N::Int, k::Vector{Int}, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with 2 electrons in k-states <code>k1</code> and <code>k2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L369-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.electronkmps" href="#MPSDynamics.electronkmps"><code>MPSDynamics.electronkmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">electronkmps(N::Int, k::Int, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS for an electron with momentum <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L333-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.elementmpo-Tuple{Any,Vararg{Any,N} where N}" href="#MPSDynamics.elementmpo-Tuple{Any,Vararg{Any,N} where N}"><code>MPSDynamics.elementmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementmpo(M, el...)</code></pre><p>Return the element of the MPO <code>M</code> for the set of physical states <code>el...</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L493-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.elementmps-Tuple{Any,Vararg{Any,N} where N}" href="#MPSDynamics.elementmps-Tuple{Any,Vararg{Any,N} where N}"><code>MPSDynamics.elementmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementmps(A, el...)</code></pre><p>Return the element of the MPS <code>A</code> for the set of physical states <code>el...</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = chainmps(6, [2,4], 1);

julia&gt; elementmps(A, 1, 2, 1, 1, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 1, 1, 2, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 2, 1, 2, 1, 1)
0.0

julia&gt; elementmps(A, 1, 1, 1, 1, 1, 1)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L460-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.entanglemententropy-Tuple{Any}" href="#MPSDynamics.entanglemententropy-Tuple{Any}"><code>MPSDynamics.entanglemententropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">entanglemententropy(A)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the entanglement entropy for a bipartite cut for every bond.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L409-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.findchainlength-Tuple{Any,Any}" href="#MPSDynamics.findchainlength-Tuple{Any,Any}"><code>MPSDynamics.findchainlength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findchainlength(T, cparams...; eps=10^-6)</code></pre><p>Estimate length of chain required for a particular set of chain parameters by calulating how long an excitation on the first site takes to reach the end. The chain length is given as the length required for the excitation to have just reached the last site after time T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/fundamentals.jl#L178-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode,Int64}" href="#MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode,Int64}"><code>MPSDynamics.findchild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findchild(node::TreeNode, id::Int)</code></pre><p>Return integer corresponding to the which number child site <code>id</code> is of <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeBasics.jl#L222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure-Tuple{Any,OneSiteObservable}" href="#MPSDynamics.measure-Tuple{Any,OneSiteObservable}"><code>MPSDynamics.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure(A, O; kwargs...)</code></pre><p>measure observable <code>O</code> on mps state <code>A</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/measure.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Array{T,1} where T,Any,Array{Int64,1}}" href="#MPSDynamics.measure1siteoperator-Tuple{Array{T,1} where T,Any,Array{Int64,1}}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(A, O)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site or just one if i is specified.</p><p>For calculating operators on single sites this will be more efficient if the site is on the left of the mps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/measure.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure2siteoperator-Tuple{Array{T,1} where T,Any,Any,Int64,Int64}" href="#MPSDynamics.measure2siteoperator-Tuple{Array{T,1} where T,Any,Any,Int64,Int64}"><code>MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> measure2siteoperator(A::Vector, M1, M2, j1, j2)</code></pre><p>Caculate expectation of M1*M2 where M1 acts on site j1 and M2 acts on site j2, assumes A is right normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/measure.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.modemps" href="#MPSDynamics.modemps"><code>MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modemps(N::Int, k::Vector{Int}, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal superposition of modes <code>k</code> of a bosonic tight-binding chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L300-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.modemps" href="#MPSDynamics.modemps"><code>MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modemps(N::Int, k::Int, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of mode <code>k</code> of a bosonic tight-binding chain. </p><p><code>chainparams</code> takes the form <code>[e::Vector, t::Vector]</code> where <code>e</code> are the on-site energies and <code>t</code> are the hoppping parameters.</p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L263-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsembed!-Tuple{Array{T,1} where T,Int64}" href="#MPSDynamics.mpsembed!-Tuple{Array{T,1} where T,Int64}"><code>MPSDynamics.mpsembed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsembed(A::Vector, Dmax::Int)</code></pre><p>Embed MPS <code>A</code> in manifold of max bond-dimension <code>Dmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L632-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsleftnorm!" href="#MPSDynamics.mpsleftnorm!"><code>MPSDynamics.mpsleftnorm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpsleftnorm!(A::Vector, jq::Int=length(A))</code></pre><p>Left orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmixednorm!-Tuple{Array{T,1} where T,Int64}" href="#MPSDynamics.mpsmixednorm!-Tuple{Array{T,1} where T,Int64}"><code>MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmixednorm!(A::Vector, OC::Int)</code></pre><p>Put MPS <code>A</code> into mixed canonical form with orthogonality centre on site <code>OC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork,Int64}" href="#MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork,Int64}"><code>MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmixednorm!(A::TreeNetwork, id::Int)</code></pre><p>Normalise tree-MPS <code>A</code> such that orthogonality centre is on site <code>id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeTDVP.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork,Int64}" href="#MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork,Int64}"><code>MPSDynamics.mpsmoveoc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmoveoc!(A::TreeNetwork, id::Int)</code></pre><p>Move the orthogonality centre of right normalised tree-MPS <code>A</code> to site <code>id</code>.</p><p>This function will be more efficient than using <code>mpsmixednorm!</code> if the tree-MPS is already right-normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeTDVP.jl#L72-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsrightnorm!" href="#MPSDynamics.mpsrightnorm!"><code>MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpsrightnorm!(A::Vector, jq::Int=1)</code></pre><p>Right orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsrightnorm!(A::TreeNetwork)</code></pre><p>When applied to a tree-MPS, right normalise towards head-node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeTDVP.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork,Int64}" href="#MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork,Int64}"><code>MPSDynamics.mpsshiftoc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsshiftoc!(A::TreeNetwork, newhd::Int)</code></pre><p>Shift the orthogonality centre by one site, setting new head-node <code>newhd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeTDVP.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.normmps-Tuple{Array{T,1} where T}" href="#MPSDynamics.normmps-Tuple{Array{T,1} where T}"><code>MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normmps(A::Vector; mpsorthog=:None)</code></pre><p>Calculate norm of MPS <code>A</code>.</p><p>Setting <code>mpsorthog</code>=<code>:Right</code>/<code>:Left</code> will calculate the norm assuming right/left canonical form. Setting <code>mpsorthog=OC::Int</code> will cause the norm to be calculated assuming the orthoganility center is on site <code>OC</code>. If mpsorthog is <code>:None</code> the norm will be calculated as an MPS-MPS product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normmps(net::TreeNetwork; mpsorthog=:None)</code></pre><p>When applied to a tree-MPS <code>mpsorthog=:Left</code> is not defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeTDVP.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.orthcentersmps-Tuple{Array{T,1} where T}" href="#MPSDynamics.orthcentersmps-Tuple{Array{T,1} where T}"><code>MPSDynamics.orthcentersmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orthcentersmps(A)</code></pre><p>Compute the orthoganality centres of MPS <code>A</code>.</p><p>Return value is a list in which each element is the corresponding site tensor of <code>A</code> with the orthoganility centre on that site. Assumes <code>A</code> is right normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.physdims-Tuple{Array{T,1} where T}" href="#MPSDynamics.physdims-Tuple{Array{T,1} where T}"><code>MPSDynamics.physdims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">physdims(M)</code></pre><p>Return the physical dimensions of an MPS or MPO <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L559-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(N::Int, d::Int, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an <code>N</code>-site MPS with all local Hilbert space dimensions given by <code>d</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(physdims::Dims, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an MPS representing a product state with local Hilbert space dimensions given by <code>physdims</code>.</p><p>By default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, <code>Dmax</code> can be set accordingly.</p><p>The indvidual states of the MPS sites can be provdided by setting <code>state</code> to a list of column vectors. Setting <code>state=:Vacuum</code> will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting <code>state=:FullOccupy</code> will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).</p><p>The argument <code>mpsorthog</code> can be used to set the gauge of the resulting MPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L134-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randisometry-Tuple{Type,Int64,Int64}" href="#MPSDynamics.randisometry-Tuple{Type,Int64,Int64}"><code>MPSDynamics.randisometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randisometry([T=Float64], dims...)</code></pre><p>Construct a random isometry</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/fundamentals.jl#L337-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps" href="#MPSDynamics.randmps"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randmps(tree::Tree, physdims, Dmax::Int, T::Type{&lt;:Number} = Float64)</code></pre><p>Construct a random, right-normalised, tree-MPS, with structure given by tree and max bond-dimension given by <code>Dmax</code>.</p><p>The local Hilbert space dimensions are specified by physdims which can either be of type <code>Dims{length(tree)}</code>, specifying the dimension of each site, or of type <code>Int</code>, in which case the same local dimension is used for every site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeTDVP.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps" href="#MPSDynamics.randmps"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randmps(N::Int, d::Int, Dmax::Int, T=Float64)</code></pre><p>Construct a random, <code>N</code>-site, right-normalised MPS with all local Hilbert space dimensions given by <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Int64}, Tuple{Tuple{Vararg{Int64,N}},Int64,Type{#s131} where #s131&lt;:Number}} where N" href="#MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Int64}, Tuple{Tuple{Vararg{Int64,N}},Int64,Type{#s131} where #s131&lt;:Number}} where N"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randmps(physdims::Dims{N}, Dmax::Int, T::Type{&lt;:Number} = Float64) where {N}</code></pre><p>Construct a random, right-normalised MPS with local Hilbert space dimensions given by <code>physdims</code> and max bond-dimension given by <code>Dmax</code>. </p><p><code>T</code> specifies the element type, eg. use <code>T=ComplexF64</code> for a complex valued MPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randtree-Tuple{Int64,Int64}" href="#MPSDynamics.randtree-Tuple{Int64,Int64}"><code>MPSDynamics.randtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randtree(numnodes::Int, maxdegree::Int)</code></pre><p>Construct a random tree with <code>nummodes</code> modes and max degree <code>maxdegree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/treeBasics.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.rmsd-Tuple{Any,Any}" href="#MPSDynamics.rmsd-Tuple{Any,Any}"><code>MPSDynamics.rmsd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmsd(dat1::Vector{Float64}, dat2::Vector{Float64})</code></pre><p>Calculate the root mean squared difference between two measurements of an observable over the same time period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/fundamentals.jl#L258-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.spinbosonmpo-NTuple{5,Any}" href="#MPSDynamics.spinbosonmpo-NTuple{5,Any}"><code>MPSDynamics.spinbosonmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spinbosonmpo(ω0, Δ, d, N, chainparams; rwa=false, tree=false)</code></pre><p>Generate MPO for a spin-1/2 coupled to a chain of harmonic oscillators, defined by the Hamiltonian</p><p><span>$H = \frac{ω_0}{2}σ_z + Δσ_x + c_0σ_x(b_k^\dagger+b_k) + \sum_{i=0}^{N-1} t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N-1} ϵ_ib_i^\dagger b_i$</span>.</p><p>The spin is on site 1 of the MPS and the bath modes are to the right.</p><p>This Hamiltonain is unitarily equivalent (before the truncation to <code>N</code> sites) to the spin-boson Hamiltonian defined by</p><p><span>$H =  \frac{ω_0}{2}σ_z + Δσ_x + σ_x\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \int_0^∞ωb_ω^\dagger b_ω$</span>.</p><p>The chain parameters, supplied by <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature.</p><p>The rotating wave approximation can be made by setting <code>rwa=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/models.jl#L288-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.svdmps-Tuple{Any}" href="#MPSDynamics.svdmps-Tuple{Any}"><code>MPSDynamics.svdmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svdmps(A)</code></pre><p>For a right normalised mps <code>A</code> compute the full svd spectrum for a bipartition at every bond.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/mpsBasics.jl#L438-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.svdtrunc-Tuple{Any}" href="#MPSDynamics.svdtrunc-Tuple{Any}"><code>MPSDynamics.svdtrunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">U, S, Vd = svdtrunc(A; truncdim = max(size(A)...), truncerr = 0.)</code></pre><p>Perform a truncated SVD, with maximum number of singular values to keep equal to <code>truncdim</code> or truncating any singular values smaller than <code>truncerr</code>. If both options are provided, the smallest number of singular values will be kept. Unlike the SVD in Julia, this returns matrix U, a diagonal matrix (not a vector) S, and Vt such that A ≈ U * S * Vt</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angusdunnett/MPSDynamics/blob/f6ea613b5b4dc55d57e52f63e110c1dac75b17c1/src/tensorOps.jl#L493-L500">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 27 May 2021 09:52">Thursday 27 May 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
